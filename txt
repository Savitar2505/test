1.
promise используют для работы с асинхронными операциями
Пример использования promise при запросе на API:
const getData = () =>{
    fetch(someURL)
        .then(response => response.ok ? response : Promise.reject(response))
        .catch(() => alert('Ошибка 404'))
        .then((data) => {
            data.json().then(response => {
            console.log(response)
            })
        })
}

2.----------------------------------------------------------------------------------------------------------------------
async await используют для работы с промисами
async возвращает промис

await заставляет ждать, пока код справа от await не выполнится. await можно использовать
только в асинхронных(async) функциях

const getData= async ()=>{
        const data = await fetch(someURL)
        const response = await data.json()
        console.log(response)
}


3.----------------------------------------------------------------------------------------------------------------------
this используется для того, чтобы присваивать переменные именно тому классу, в котором они были определены.
Таким образом они будут использовать свои собственные значения, а не какие-либо другие.

class Transport {
    constructor(name, type, maxSpeed) {
        this.name = name
        this.type = type
        this.maxSpeed = maxSpeed
    }
}
class Car extends Transport {
    constructor(name, type, maxSpeed) {
        super(name, type, maxSpeed);
    }
}
const bmw = new Car("BMW", "car", 500)


4-----------------------------------------------------------------------------------------------------------------------
Замыкание это механизм, который дает доступ к переменным внешней функции из внутренней

const Hello = () => {
  const message = 'Hello, ';
  return function(name) {
    return message + name + '!';
  }
}

const result = sayHello();
console.log(result('John'))

5.----------------------------------------------------------------------------------------------------------------------

1 отличие - this:

В обычных функциях this динамичное
Значением this в глобальной области видимости будет объект window

Значением this в стрелочных функциях является значение внешней родительской функции

2 отличие - неявный return:

Создание обычной функции скрытно возвращает undefined

В стрелочных функциях присутствует функционал, который позволяет не писать return

3 отличие - конструкторы:

Обычные функции используют для создания функций-конструкторов

У стрелочных функций нет своего this. Поэтому их не используют для создания конструкторов


